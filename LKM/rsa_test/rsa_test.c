#define pr_fmt(fmt) "%s: " fmt, KBUILD_MODNAME

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/scatterlist.h>
#include <crypto/akcipher.h>
#include <crypto/internal/akcipher.h>
#include <crypto/internal/rsa.h>

static void hexdump(const unsigned char *buf, unsigned int len) {
	print_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,
			16, 1,
			buf, len, false);
}

#define XBUFSIZE	8
char *xbuf[XBUFSIZE];

static int __testmgr_alloc_buf(char *buf[XBUFSIZE], int order) {
	int i;

	for (i = 0; i < XBUFSIZE; i++) {
		buf[i] = (char *)__get_free_pages(GFP_KERNEL, order);
		if (!buf[i])
			goto err_free_buf;
	}

	return 0;

err_free_buf:
	while (i-- > 0)
		free_pages((unsigned long)buf[i], order);

	return -ENOMEM;
}

static int testmgr_alloc_buf(char *buf[XBUFSIZE]) {
	return __testmgr_alloc_buf(buf, 0);
}

static void __testmgr_free_buf(char *buf[XBUFSIZE], int order) {
	int i;

	for (i = 0; i < XBUFSIZE; i++)
		free_pages((unsigned long)buf[i], order);
}

static void testmgr_free_buf(char *buf[XBUFSIZE]) {
	__testmgr_free_buf(buf, 0);
}

const unsigned char rsa_key[] =
    "\x30\x82\x04\xA3\x02\x01\x00\x02\x82\x01\x01\x00\x9F\x60\xE7\xB8"
    "\x2F\x85\x21\x99\x4B\x6F\x9C\x4F\xBA\x25\x54\xD3\xBE\xD5\x06\x2D"
    "\xC3\xD7\xD8\x05\x05\x27\xD5\xF7\xBC\x37\x6C\x92\xCA\x08\xAA\x5B"
    "\x5D\xFF\x23\x29\x17\x83\x92\x56\x6A\x7A\x74\x20\x2D\x2C\xB0\xF1"
    "\x77\x1D\x6A\x17\x85\x73\xF3\xDF\xE6\x21\x4D\x9F\xE0\x86\xEA\x7D"
    "\x5D\x29\x6E\xF6\xA3\x19\xC8\x60\xD7\x9F\xFD\x25\xD4\x05\xAC\x22"
    "\xB2\xBA\xE6\x68\xFC\x59\x34\xC2\xF4\x8D\xEA\x66\x27\x8E\x4D\x3B"
    "\x33\x58\xD1\xD5\x99\x90\x13\xAF\xC1\xC6\x22\xA7\x33\xB3\x05\xB9"
    "\x3E\xA0\x67\x73\xAA\xEC\x75\xD9\x2D\x27\x46\xF5\x5F\x2D\xF2\x45"
    "\xF8\xF4\xE0\x1C\x43\x3E\x57\xDD\x1B\xAB\x13\xB7\x42\xCD\x5F\x57"
    "\x7B\xA5\x5D\x2B\x71\x3D\xC6\xF8\xDE\xD9\x1B\xFE\xA7\x39\x9C\xAF"
    "\xFC\xCE\x4C\x04\x30\xC1\x22\xDA\xB3\xC4\x17\xAB\x94\xA2\xD4\xC8"
    "\x65\x5F\xE5\xE9\x3E\x05\x93\x7D\xA3\x74\x97\x9C\x47\xDF\x54\x4F"
    "\x91\xEE\x7A\x1E\xEB\x21\x34\x8C\x6E\x29\x8C\x8E\x2C\x54\x95\x5C"
    "\xF8\xFD\xAE\x24\x76\x04\x76\x81\xAD\xC5\x10\x00\xB9\xFF\xCB\xED"
    "\xE5\x0C\x06\xD1\xB9\xC4\x79\x58\x65\xC3\x92\x81\x4C\x41\x1C\x4E"
    "\x5E\x47\x9F\x06\x04\x1E\x1C\x1D\xEE\x69\x97\x51\x02\x03\x01\x00"
    "\x01\x02\x82\x01\x01\x00\x89\x97\xFC\x94\xBB\x99\xC0\xF6\xF9\xF4"
    "\x42\x4B\x66\x56\x02\x54\xC7\xE4\x5A\xF0\x39\xAA\x67\x59\x76\x28"
    "\xFD\x05\x62\x5D\xAB\x03\x53\x1E\x86\x0C\x59\x2B\x02\x2C\xE0\x9A"
    "\xFB\x44\x55\xAA\xA0\x04\x83\x5B\x98\xEA\xED\xBD\xDC\x30\xB0\x4A"
    "\xF9\x99\x2B\xB1\x46\xB5\xA6\xFE\x73\x04\x85\xE0\x56\x66\xE1\x4A"
    "\x49\xFE\xA9\x48\xFB\x20\xA4\x59\xBD\x51\x3B\x62\x35\xB7\x1F\x5C"
    "\xD8\x3B\x13\x2C\x4D\xD7\xA1\x80\xAD\xD6\x55\x2E\xF2\x00\xE9\x11"
    "\x44\x9D\xB0\xB9\xA0\x83\x1F\x14\x07\xF5\xF4\x46\x40\xE9\xCF\xFF"
    "\x52\x82\x8B\x03\xE4\xB2\x66\x67\x71\xB6\x26\x21\xCC\x73\xDC\xE4"
    "\x4A\xDB\x6B\x4D\x31\xE5\x73\x06\xE8\x91\x03\x1D\xD7\xDE\x63\xC3"
    "\x43\xFE\x99\xCB\x17\x3F\x91\xE1\xD3\xAD\x07\x96\x0F\x18\x23\x43"
    "\xB3\x62\xDE\xBD\xC9\x27\x04\x7E\x7D\x0F\x64\x61\xDD\x4E\xAC\x05"
    "\xF4\xBC\x3D\x69\x92\x83\x37\xED\xB7\x99\x3F\x18\x40\x1B\x9D\x02"
    "\x7D\x5D\x20\x56\x0E\xA3\x81\xD6\x2E\x87\xDE\xC7\x99\x57\x45\xB2"
    "\xE5\xAC\x4A\xC7\xA8\xB6\x66\x54\xE3\x55\xF0\x6E\x38\xE1\xEE\x05"
    "\x1B\xDC\x5D\xC7\x1F\x36\xAD\x8C\x09\xAE\xC0\xD3\xC1\x0C\x1B\x3B"
    "\xF2\x21\x68\x19\xAE\x01\x02\x81\x81\x00\xD0\x67\x41\xD9\x9D\x83"
    "\x63\xC3\xE1\xA9\x88\x1F\x97\x10\x84\x40\x00\x4F\xAC\x09\x57\x8C"
    "\xB1\x50\x5D\x88\xDD\x29\x31\xAE\x9B\x20\x54\x1A\x37\xE1\x71\x6D"
    "\x7C\x7B\x32\xE4\xEC\xA1\xFC\x54\x63\xDE\xAB\x25\x8B\x59\x46\xE0"
    "\x7C\xCE\xAD\xC3\xFB\xFA\xF3\x8B\xAA\x90\x45\x0C\x1B\xD6\xC5\xBC"
    "\xA9\x3B\x84\x5B\x45\xF6\x92\x38\xBD\x17\x9E\xCD\xE0\x3F\x94\xBB"
    "\x86\x9D\xBD\x1E\xBB\x23\x50\x3E\x25\x1D\x15\x63\x19\xF4\xE5\xC9"
    "\xA7\x05\x3F\x37\xCF\x92\x1E\xF2\xBF\xF1\x29\x20\x79\x65\x6E\xEF"
    "\x05\x83\x89\x49\x66\x6C\x5A\x9D\xE6\x61\x02\x81\x81\x00\xC3\xC7"
    "\x4E\xFA\x50\x6E\x38\x86\xDE\xD0\x53\x47\x12\x30\xD5\x04\x0C\x8A"
    "\xC2\xA8\x60\xA1\xDC\xFA\x93\x20\x78\x45\x35\xA9\x96\x43\x34\xA4"
    "\x8F\x87\x78\x58\xDB\x98\xD1\x36\x33\x16\x81\x4F\x3E\x35\xD4\xC8"
    "\x46\x9D\xA1\x68\x7C\x4E\xF7\x6A\x52\xE4\xB1\xE2\x2A\x9E\x87\xDA"
    "\xC1\x9A\xE3\x41\x25\x01\xB1\x85\x16\x6A\xE7\x4B\xF4\x7B\x30\x3E"
    "\x32\xC7\x10\x82\x75\x48\x6C\x16\x12\x51\x61\xCF\xE4\xB1\xD9\x5D"
    "\x17\xFF\xEB\xBE\x65\xDC\x70\x05\x3B\x63\x9A\xD1\x6E\xF1\xDD\xBB"
    "\xF8\x92\x4B\x71\x67\x82\x29\x6C\x57\xB3\x9A\x73\x76\xF1\x02\x81"
    "\x80\x31\x91\x9D\xD4\x08\xE7\x0B\x7F\xB7\xD8\xFF\x0B\xA4\x7E\xC5"
    "\x36\x03\xDC\xEF\x6A\x79\x6C\x79\x70\x48\x0F\x19\xAB\x86\xA9\xA5"
    "\x34\x17\x4C\xF5\x25\xA6\x39\x08\x76\xB5\x30\x46\x28\x71\x40\x11"
    "\x51\x11\x1C\x28\xFC\xDF\x22\xDE\x0C\xBA\xBF\xF6\xDB\x45\xBA\x5E"
    "\xA3\x5A\x08\xFB\x46\x26\x5A\x2D\x56\x7E\xB0\xC6\xFF\x52\xE0\x33"
    "\xF9\xBE\x47\xF1\xA2\xAD\xD9\xBC\xB7\x20\x18\x83\x22\x6F\x1F\x98"
    "\xEC\x45\xFE\x00\x5A\x83\x9D\x67\x20\x94\x5C\xCD\xFE\x4F\x66\x25"
    "\xC9\x52\xA2\xEA\xBC\xF9\x99\xD8\x91\xE4\xC1\x94\x9F\x09\x1E\xAD"
    "\x81\x02\x81\x80\x7F\xE2\x1C\x03\xC4\x30\x0B\x3A\x86\x26\xFC\x8E"
    "\xEB\x21\xFC\xB3\x15\x62\x3A\x7E\xF4\x08\x27\x29\x82\x9B\x6E\x14"
    "\x7F\x56\x14\x72\x37\xDB\xDA\x69\x7A\x42\x48\xC7\x4C\xB9\xA3\xAB"
    "\x6A\xB2\x11\x87\xE6\x43\x20\x65\x6C\xFE\xAC\x5C\x84\x9E\xEE\x20"
    "\xB6\xD5\x6E\x53\x79\x98\x7A\x68\xAB\x53\x6D\x51\xEA\xDC\x6D\x65"
    "\x4D\x4A\xBF\x1B\x0C\xCB\x44\x2D\xE5\xE9\xE1\xA4\x79\xFD\xFC\xDF"
    "\x2E\x0E\x37\x6B\xB8\xF9\x67\x68\xE3\x5B\xCE\x7B\xAC\xAC\xAE\x3B"
    "\x84\xF0\x93\x10\xE8\x6F\x15\x92\xB2\x37\x14\x8E\xE0\x72\x05\xE3"
    "\xAA\xDB\x0B\x71\x02\x81\x80\x41\x8D\x1A\xE6\xE2\x04\xF9\x7D\x60"
    "\xC4\x1E\x10\x03\x44\x25\xD5\x7B\x5D\xF1\xAC\xB0\x6A\xD3\x42\xE1"
    "\x9A\xC2\xB8\x26\xB8\xB2\xA9\x32\x9C\x26\x3C\x6B\x87\x62\x1E\x33"
    "\xE5\xA2\x37\x1A\xD9\x29\x8A\x0B\xF2\x4E\x02\x42\x81\x37\x21\x8A"
    "\x75\x12\xD7\x54\x45\xF3\x30\xDB\x3B\xC7\x0F\x0B\xD1\x4B\x00\xED"
    "\xB0\x4B\xD4\x6D\xDB\xE4\x1D\xC9\x2B\xB9\xD6\x61\x40\x74\x4A\x8D"
    "\x50\x60\xCB\x99\xD4\x34\xEA\x8F\xB5\xD2\xFF\xCC\xD3\x5C\x3B\x4A"
    "\x33\xA9\x1E\x88\x9F\x92\x69\x45\x3A\xF8\x4D\x53\x4C\x78\x95\x13"
    "\x51\x19\xB3\x24\x15\x9E\x14";
const unsigned int rsa_key_len = 1191;

const unsigned char rsa_msg[] =
	"\x49\x41\xbe\x0a\x0c\xc9\xf6\x35\x51\xe4\x27\x56\x13\x71\x4b\xd0"
	"\x36\x92\x84\x89\x1b\xf8\x56\x4a\x72\x61\x14\x69\x4f\x5e\x98\xa5"
	"\x80\x5a\x37\x51\x1f\xd8\xf5\xb5\x63\xfc\xf4\xb1\xbb\x4d\x33\xa3"
	"\x1e\xb9\x75\x8b\x9c\xda\x7e\x6d\x3a\x77\x85\xf7\xfc\x4e\xe7\x64"
	"\x43\x10\x19\xa0\x59\xae\xe0\xad\x4b\xd3\xc4\x45\xf7\xb1\xc2\xc1"
	"\x65\x01\x41\x39\x5b\x45\x47\xed\x2b\x51\xed\xe3\xd0\x09\x10\xd2"
	"\x39\x6c\x4a\x3f\xe5\xd2\x20\xe6\xb0\x71\x7d\x5b\xed\x26\x60\xf1"
	"\xb4\x73\xd1\xdb\x7d\xc4\x19\x91\xee\xf6\x32\x76\xf2\x19\x7d\xb7";
const unsigned int rsa_msg_size = 128;
const unsigned char rsa_digest[] =
	"\x3e\xc8\xa1\x26\x20\x54\x44\x52\x48\x0d\xe5\x66\xf3\xb3\xf5\x04"
	"\xbe\x10\xa8\x48\x94\x22\x2d\xdd\xba\x7a\xb4\x76\x8d\x79\x98\x89";
const unsigned int rsa_digest_size = 32;
const unsigned char rsa_sig[] =
	"\xc7\xa3\x98\xeb\x43\xd1\x08\xc2\x3d\x78\x45\x04\x70\xc9\x01\xee"
	"\xf8\x85\x37\x7c\x0b\xf9\x19\x70\x5c\x45\x7b\x2f\x3a\x0b\xb7\x8b"
	"\xc4\x0d\x7b\x3a\x64\x0b\x0f\xdb\x78\xa9\x0b\xfd\x8d\x82\xa4\x86"
	"\x39\xbf\x21\xb8\x84\xc4\xce\x9f\xc2\xe8\xb6\x61\x46\x17\xb9\x4e"
	"\x0b\x57\x05\xb4\x4f\xf9\x9c\x93\x2d\x9b\xd5\x48\x1d\x80\x12\xef"
	"\x3a\x77\x7f\xbc\xb5\x8e\x2b\x6b\x7c\xfc\x9f\x8c\x9d\xa2\xc4\x85"
	"\xb0\x87\xe9\x17\x9b\xb6\x23\x62\xd2\xa9\x9f\x57\xe8\xf7\x04\x45"
	"\x24\x3a\x45\xeb\xeb\x6a\x08\x8e\xaf\xc8\xa0\x84\xbc\x5d\x13\x38"
	"\xf5\x17\x8c\xa3\x96\x9b\xa9\x38\x8d\xf0\x35\xad\x32\x8a\x72\x5b"
	"\xdf\x21\xab\x4b\x0e\xa8\x29\xbb\x61\x54\xbf\x05\xdb\x84\x84\xde"
	"\xdd\x16\x36\x31\xda\xf3\x42\x6d\x7a\x90\x22\x9b\x11\x29\xa6\xf8"
	"\x30\x61\xda\xd3\x8b\x54\x1e\x42\xd1\x47\x1d\x6f\xd1\xcd\x42\x0b"
	"\xd1\xe4\x15\x85\x7e\x08\xd6\x59\x64\x4c\x01\x34\x91\x92\x26\xe8"
	"\xb0\x25\x8c\xf8\xf4\xfa\x8b\xc9\x31\x33\x76\x72\xfb\x64\x92\x9f"
	"\xda\x62\x8d\xe1\x2a\x71\x91\x43\x40\x61\x3c\x5a\xbe\x86\xfc\x5b"
	"\xe6\xf9\xa9\x16\x31\x1f\xaf\x25\x6d\xc2\x4a\x23\x6e\x63\x02\xa2";
const unsigned int rsa_sig_size = 256;

static int rsa_pkcs1pad_sign_verify_test(void) {
    int err = -ENOMEM;
    struct crypto_wait wait;
    struct crypto_akcipher *tfm;
    struct akcipher_request *req;
    struct scatterlist src, dst, src_tab[2];
    u8 *outbuf;
    unsigned int rsa_key_size;
    struct rsa_key raw_key = {0};

    pr_info("[+] RSA pkcs1pad sign/verify test\n");

    tfm = crypto_alloc_akcipher("pkcs1pad(rsa,sha256)", 0, 0);
    if (IS_ERR(tfm))
        return PTR_ERR(tfm);

    req = akcipher_request_alloc(tfm, GFP_KERNEL);
    if (!req)
        goto error_free_tfm;

    crypto_init_wait(&wait);

    err = crypto_akcipher_set_priv_key(tfm, rsa_key, rsa_key_len);
    if (err)
        goto error_free_req;

    rsa_key_size = crypto_akcipher_maxsize(tfm);
    pr_info("Key size: %d\n", rsa_key_size);

    rsa_parse_priv_key(&raw_key, rsa_key, rsa_key_len);
    pr_info("raw_key.d:\n");
    hexdump(raw_key.d, raw_key.d_sz);
    pr_info("raw_key.e:\n");
    hexdump(raw_key.e, raw_key.e_sz);
    pr_info("raw_key.n:\n");
    hexdump(raw_key.n, raw_key.n_sz);
    pr_info("raw_key.p:\n");
    hexdump(raw_key.p, raw_key.p_sz);
    pr_info("raw_key.q:\n");
    hexdump(raw_key.q, raw_key.q_sz);

    outbuf = kzalloc(rsa_key_size, GFP_KERNEL);
    if (!outbuf)
        goto error_free_req;

    // sign
    memcpy(xbuf[0], rsa_digest, rsa_digest_size);
    // NOTE: must set heap memory address with sg, cannot directly use stack address
    sg_init_one(&src, xbuf[0], rsa_digest_size);
    sg_init_one(&dst, outbuf, rsa_key_size);
    akcipher_request_set_crypt(req, &src, &dst, rsa_digest_size, rsa_key_size);

    crypto_init_wait(&wait);
    akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait);
    err = crypto_wait_req(crypto_akcipher_sign(req), &wait);
    pr_info("RSA signature generation: %d\n", err);
    pr_info("req->dst_len=%d\n", req->dst_len);
    if (req->dst_len < rsa_sig_size) {
        pr_err("Invalid output len %u\n", req->dst_len);
        goto error_free_outbuf;
    }
    pr_info("Signature:\n");
    hexdump(outbuf, rsa_key_size);

    // verification
    sg_init_table(src_tab, 2);
    sg_set_buf(&src_tab[0], outbuf, rsa_key_size);
    sg_set_buf(&src_tab[1], xbuf[0], rsa_digest_size);
    akcipher_request_set_crypt(req, src_tab, NULL, rsa_key_size, rsa_digest_size);

    err = crypto_wait_req(crypto_akcipher_verify(req), &wait);
    pr_info("RSA signature verification: %d\n", err);
    pr_info("req->dst_len=%d\n", req->dst_len);

    if (err) {
        pr_info("[-] failed\n");
    } else {
        pr_info("[+] success\n");
    }

error_free_outbuf:
    kfree(outbuf);
error_free_req:
    akcipher_request_free(req);
error_free_tfm:
    crypto_free_akcipher(tfm);
    return err;
}

static int rsa_encrypt_decrypt_test(void) {
    int err = -ENOMEM;
    struct crypto_wait wait;
    struct crypto_akcipher *tfm;
    struct akcipher_request *req;
    struct scatterlist src, dst, src2, dst2;
    u8 *outbuf;
    u8 *outbuf2;
    unsigned int rsa_key_size;

    pr_info("[+] RSA encrypt/decrypt test\n");

    tfm = crypto_alloc_akcipher("rsa", 0, 0);
    if (IS_ERR(tfm))
        return PTR_ERR(tfm);

    req = akcipher_request_alloc(tfm, GFP_KERNEL);
    if (!req)
        goto error_free_tfm;

    crypto_init_wait(&wait);

    err = crypto_akcipher_set_priv_key(tfm, rsa_key, rsa_key_len);
    if (err)
        goto error_free_req;

    rsa_key_size = crypto_akcipher_maxsize(tfm);
    pr_info("Key size: %d\n", rsa_key_size);

    outbuf = kzalloc(rsa_key_size, GFP_KERNEL);
    if (!outbuf)
        goto error_free_req;
    outbuf2 = kzalloc(rsa_key_size, GFP_KERNEL);
    if (!outbuf2)
        goto error_free_outbuf;

    pr_info("Input:\n");
    hexdump(rsa_digest, rsa_digest_size);

    // encryption
    memcpy(xbuf[0], rsa_digest, rsa_digest_size);
    sg_init_one(&src, xbuf[0], rsa_digest_size);
    sg_init_one(&dst, outbuf, rsa_key_size);
    akcipher_request_set_crypt(req, &src, &dst, rsa_digest_size, rsa_key_size);

    crypto_init_wait(&wait);
    akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG, crypto_req_done, &wait);
    err = crypto_wait_req(crypto_akcipher_encrypt(req), &wait);

    // decryption
    crypto_init_wait(&wait);
    sg_init_one(&src2, outbuf, rsa_key_size);
    sg_init_one(&dst2, outbuf2, rsa_key_size);
    akcipher_request_set_crypt(req, &src2, &dst2, rsa_key_size, rsa_key_size);

    err = crypto_wait_req(crypto_akcipher_decrypt(req), &wait);
    if (memcmp(rsa_digest, outbuf2 + req->dst_len - rsa_digest_size, rsa_digest_size)) {
        pr_info("[-] failed!\n");
    } else {
        pr_info("[+] success!\n");
    }
    goto error_free_outbuf2;

error_free_outbuf2:
    kfree(outbuf2);
error_free_outbuf:
    kfree(outbuf);
error_free_req:
    akcipher_request_free(req);
error_free_tfm:
    crypto_free_akcipher(tfm);
    return err;
}

static int __init rsa_test_init(void) {
    int err = -ENOMEM;
    pr_info("Initializing RSA test module\n");

	if (testmgr_alloc_buf(xbuf))
		return err;

    rsa_encrypt_decrypt_test();

    rsa_pkcs1pad_sign_verify_test();

    testmgr_free_buf(xbuf);
    return 0;
}

static void __exit rsa_test_exit(void) {
    pr_info("Exiting RSA test module\n");
}

module_init(rsa_test_init);
module_exit(rsa_test_exit);

MODULE_AUTHOR("Shengtuo Hu");
MODULE_LICENSE("GPL");
MODULE_VERSION("0.01");
